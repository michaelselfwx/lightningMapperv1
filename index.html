<!DOCTYPE html>
<html lang="en">
<head>
    <title>SPC Outlook Mapper</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="description" content="" />

    <!-- CSS for the page and the map -->
    <style>
        html,
        body,
        #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%; 
            width: 100%;
        }
        #dateDiv {
            position: absolute;
            top: 1%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 1);
            border: 1px solid black;
            border-radius: 5px;
            z-index: 1000;
            width: 28%; /* fixed width */
            height: 5%; /* fixed height */
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(0.5px + 1vw); /* adjust as needed */
        }
        /* For mobile devices */
        @media screen and (max-width: 768px) {
            #dateDiv {
                width: 50%; /* adjust as needed */
                height: 7%; /* adjust as needed */
                font-size: calc(1px + 3vw); /* adjust as needed */
            }
            #toggle-left, #toggle-right {
                font-size: calc(1px + 3vw); /* adjust as needed */
            }
        }
        /* For iPads */
        @media screen and (min-width: 769px) and (max-width: 1024px) {
            #dateDiv {
                width: 40%; /* adjust as needed */
                height: 5%; /* adjust as needed */
                font-size: calc(1px + 2vw); /* adjust as needed */
            }
            #toggle-left, #toggle-right {
                font-size: calc(1px + 2vw); /* adjust as needed */
            }
        }
        .small-legend {
            transform: scale(0.8); /* Adjust as needed */
            position: absolute;
            bottom: 0;
            left: 0;
            padding: 10px;
        }

        .sidebar {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 200px; /* adjust as needed */
            display: none; /* initially hidden */
        }
        #left-column {
            left: 0;
        }

        #right-column {
            right: 0;
        }
        #toggle-left, #toggle-right {
            position: absolute;
            top: 10px;
        }

        #toggle-left {
            left: 10px;
        }

        #toggle-right {
            right: 10px;
        }
    </style>

    <!-- ArcGIS API's CSS file and JS library -->
    <link rel="stylesheet" href="https://js.arcgis.com/4.25/esri/themes/light/main.css">
    <script src="https://js.arcgis.com/4.25/"></script>

</head>
<body>

    <!-- The div to display the map -->
    <div id="viewDiv"></div>
    <div id="dateDiv"></div>
    <div id="left-column" class="sidebar">
        <h2>View Selections</h2>
        <input type="checkbox" id="layer1" checked>
        <label for="layer1">SPC Day 1 Convective Outlook</label><br>
        <input type="checkbox" id="layer2" checked>
        <label for="layer2">Layer 2</label><br>
        <input type="checkbox" id="layer3" checked>
        <label for="layer3">Layer 3</label><br>
    </div>
    <div id="right-column" class="sidebar">Storm Reports</div>
    <button id="toggle-left">Menu</button>
    <button id="toggle-right">Add Report</button>

    <!-- JavaScript for the map -->
    <script>
        require([
            "esri/config",
            "esri/Map",
            "esri/Graphic",
            "esri/views/MapView",
            "esri/layers/GeoJSONLayer",
            "esri/widgets/Legend",
            "esri/widgets/Search",
            "esri/widgets/LayerList",
            "esri/widgets/Editor"
        ], function (esriConfig, Map, MapView, GeoJSONLayer, Legend, Search, LayerList, Editor, Graphic) {
            // Set the API key
            esriConfig.apiKey = "AAPKfb3b968ef66d4c848e795b3dd01897e8uTic-7qcXbjlpUVMGReQlWKWAjnWq5pH5r7mLxpcFbX1tfR5Y4bLBPhLOwFOm7NL";

            // Make sure the page refreshes when the user is inactive
            var timeout;
            var delay = 5 * 60 * 1000; // 5 minutes

            function resetTimeout() {
                clearTimeout(timeout);
                timeout = setTimeout(function() {
                    location.reload();
                }, delay);
            }

            window.onload = resetTimeout;
            window.onmousemove = resetTimeout;
            window.onmousedown = resetTimeout; 
            window.ontouchstart = resetTimeout;
            window.onclick = resetTimeout;     
            window.onscroll = resetTimeout;    
            window.onkeypress = resetTimeout;

            // Create the map and view
            var map = new Map({
                basemap: "topo-vector",          
            });
            var view = new MapView({
                container: "viewDiv",
                map: map,
                center: [-98.5795, 37.8283],
                ui: {
                    components: ["attribution"]
                }
            });

            view.scale = 18650000; // Sets a 1:24,0000 scale on the view

            // Add this block of code
            var layerList;
            view.when(function() {
                if (!layerList) {
                    // Create a new LayerList instance and set its container to a div element
                    layerList = new LayerList({
                        view: view
                    });

                    // Add the LayerList to the left sidebar
                    document.getElementById("left-column").appendChild(layerList.container);
                }
            });

            document.getElementById('toggle-left').addEventListener('click', function() {
                toggleSidebar('left-column');
            });

            document.getElementById('toggle-right').addEventListener('click', function() {
                toggleSidebar('right-column');
            });

            function toggleSidebar(id) {
                var sidebar = document.getElementById(id);
                sidebar.style.display = sidebar.style.display === 'none' ? 'block' : 'none';
            }

            // Define the available hours
            var availableHours = [1, 12, 13, 16.5, 20];

            // Get the current date and time
            var date = new Date();
            var year = date.getUTCFullYear();
            var month = ('0' + (date.getUTCMonth() + 1)).slice(-2);
            var day = ('0' + date.getUTCDate()).slice(-2);
            var hour = date.getUTCHours().toString().padStart(2, '0');

            // Determine the closest available hour
            var closestHour, result;
            if (hour < availableHours[0]) {
                // If the current hour is before the first available hour, use the last available hour from the previous day
                closestHour = availableHours[availableHours.length - 1];
                date.setDate(date.getDate() - 1);
                year = date.getUTCFullYear();
                month = ('0' + (date.getUTCMonth() + 1)).toString().slice(-2);
                day = ('0' + (date.getUTCDate()).toString().slice(-2));
                result = { closestHour: closestHour, date: { year: year, month: month, day: day } };
            } else {
                // Otherwise, use the available hour that is closest to the current hour
                closestHour = availableHours.reduce(function(prev, curr) {
                    return (curr <= hour && Math.abs(curr - hour) < Math.abs(prev - hour) ? curr : prev);
                });
                result = { closestHour: closestHour, date: date };
            }

            // Define a function to get the previous available hour
            function getPreviousHour(hour, date) {
                var index = availableHours.indexOf(hour);
                if (index > 0) {
                    return { hour: availableHours[index - 1], date: date };
                } else {
                    date.setDate(date.getDate() - 1);
                    var year = date.getUTCFullYear();
                    var month = ('0' + (date.getUTCMonth() + 1)).slice(-2);
                    var day = ('0' + date.getUTCDate()).slice(-2);
                    return { hour: availableHours[availableHours.length - 1], date: { year: year, month: month, day: day } };
                }
            }

            // Define a function to get the URL for a given hour and date
            function getUrl(hour, date) {
                var minutes = Math.round((hour % 1) * 60);
                hour = ('0' + Math.floor(hour)).slice(-2);
                minutes = ('0' + minutes).slice(-2);
                var formattedDateTime = date.year + date.month + date.day + '_' + hour + minutes;
                var url = "https://ham-shack-pi.tail8c79a.ts.net/proxy?url=https://www.spc.noaa.gov/products/outlook/archive/2024/day1otlk_" + formattedDateTime + "_cat.lyr.geojson";
                return { url: url, formattedDateTime: formattedDateTime}
            }

            // Get the data for the closest available hour
            var urlData = getUrl(closestHour, { year: year, month: month, day: day });
            console.log(urlData.url);

            // Fetch the data for the closest available hour
            fetch(urlData.url)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Data for the new hour is available, proceed as normal
                    createGeoJSONLayer(urlData, data);
                })
                .catch(function(error) {
                    // Data for the new hour is not available, use the previous hour
                    var previous = getPreviousHour(closestHour, date);
                    url = getUrl(previous.hour, previous.date);
                    createGeoJSONLayer(url);
                });

            // Define a function to create a GeoJSON layer
            function createGeoJSONLayer(url, data) {
                var renderer = {
                    type: "unique-value",
                    field: "LABEL2",
                    uniqueValueInfos: [
                        { 
                            value: "General Thunderstorms Risk", 
                            symbol: {
                                type: "simple-fill", 
                                color: [0, 128, 0, 0.25], 
                                outline: { width: 0.5, color: "black" }
                            }
                        },
                        { 
                            value: "Marginal Risk", 
                            symbol: {
                                type: "simple-fill", 
                                color: [255, 255, 0, 0.30], 
                                outline: { width: 0.5, color: "black" }
                            }
                        },
                        { 
                            value: "Slight Risk", 
                            symbol: {
                                type: "simple-fill", 
                                color: [255, 165, 0, 0.35], 
                                outline: { width: 0.5, color: "black" }
                            }
                        },
                        { 
                            value: "Enhanced Risk", 
                            symbol: {
                                type: "simple-fill", 
                                color: [255, 75, 0, 0.40], 
                                outline: { width: 0.5, color: "black" }
                            }
                        },
                        { 
                            value: "Moderate Risk", 
                            symbol: {
                                type: "simple-fill", 
                                color: [255, 0, 0, 0.45], 
                                outline: { width: 0.5, color: "black" }
                            }
                        },
                        { 
                            value: "High Risk", 
                            symbol: {
                                type: "simple-fill", 
                                color: [255, 0, 255, 0.5], 
                                outline: { width: 0.5, color: "black" }
                            }
                        }
                    ]
                };
                var geojsonLayer = new GeoJSONLayer({
                    url: urlData.url,
                    renderer: renderer,
                    popupTemplate: {
                        title: "Categorical Outlook",
                        content: "{LABEL2}"
                    }
                });

                 // Add the GeoJSON layer to the map
                if (!map.findLayerById('geojsonLayer')) {
                    geojsonLayer.id = 'geojsonLayer';
                    map.add(geojsonLayer);
                } else {
                    map.findLayerById('geojsonLayer').url = urlData.url;
                }

                // Add a click event handler to the view
                view.on("click", function(event) {
                    view.hitTest(event).then(function(response) {
                        if (response.results.length) {
                            // Sort the results by DN in descending order
                            response.results.sort(function(a, b) {
                                return b.graphic.attributes.DN - a.graphic.attributes.DN;
                            });

                            // Get the graphic with the highest DN
                            var graphic = response.results[0].graphic;

                            // Show the popup
                            view.popup.open({
                                features: [graphic],
                                location: event.mapPoint
                            });
                        }
                    });
                });

                // Create a legend and add it to the view
                if (!view.ui.find("legend")) {
                    var legend = new Legend({
                        view: view,
                        container: document.createElement("div"),
                        layerInfos: [
                            {
                                layer: geojsonLayer,
                                title: "Day 1 Convective Outlook"
                            },
                        ]
                    });

                    var legendContainer = document.createElement("div");
                    legendContainer.className = "small-legend";
                    legendContainer.appendChild(legend.container);
                    view.ui.add(legendContainer);

                // Create a search widget and add it to the view
                if (!view.ui.find("search")) {
                    var search = new Search({
                        view: view,
                        container: document.createElement("div"),
                        layerInfos: [
                            {
                                layer: geojsonLayer,
                                placeholder: "Search for a location"
                            }],
                        }
                    )};
                

                // Update the date div
                if (data) {
                    var validTime = data.features[0].properties.VALID;
                    var expireTime = data.features[0].properties.EXPIRE;

                    var validFormatted = validTime.substring(4,6) + "/" + validTime.substring(6,8) + "/" + validTime.substring(0,4) + " @ " + validTime.substring(8,10) + validTime.substring(10,12) + " UTC";
                    var expireFormatted = expireTime.substring(4,6) + "/" + expireTime.substring(6,8) + "/" + expireTime.substring(0,4) + " @ " + expireTime.substring(8,10) + expireTime.substring(10,12) + " UTC";

                    var dateDiv = document.getElementById('dateDiv');
                    if (!dateDiv.textContent) {
                        dateDiv.textContent = 'Valid: ' + validFormatted + ' - ' + expireFormatted;
                    }
                };
            }
            
            // URL of the GeoJSON data
            var geoJsonUrl = "https://mesonet.agron.iastate.edu/data/gis/shape/4326/us/lsr_24hour.geojson";

            // Fetch GeoJSON data
            fetch(geoJsonUrl)
                .then(response => response.json())
                .then(data => {
                    // Process GeoJSON data and create graphics for each storm report
                    data.features.forEach(function(feature) {
                        var lon = feature.geometry.coordinates[0];
                        var lat = feature.geometry.coordinates[1];
                        var type = feature.properties.TYPETEXT;

                        // Create a point geometry
                        var point = {
                            type: "point",
                            longitude: lon,
                            latitude: lat
                        };

                        // Create a symbol for the point based on storm report type
                        var symbol;
                        if (type === "HAIL") {
                            symbol = {
                                type: "simple-marker",
                                color: "blue",
                                size: "10px"
                            };
                        } else if (type === "SNOW") {
                            symbol = {
                                type: "simple-marker",
                                color: "white",
                                outline: {
                                    color: "blue",
                                    width: 1
                                },
                                size: "10px"
                            };
                        } else {
                            // Default symbol for other types of reports
                            symbol = {
                                type: "simple-marker",
                                color: "red",
                                size: "10px"
                            };
                        }

                        // Create a graphic and add it to the map
                        var graphic = new Graphic({
                            geometry: point,
                            symbol: symbol
                        });
                        view.graphics.add(graphic);
                    });
                })
                .catch(error => {
                    console.error("Error fetching GeoJSON data:", error);
                });
            
            // Toggle layers based on sidebar checkboxes
            document.getElementById("layer1").addEventListener("change", function() {
                    layer1.visible = this.checked;
                });
            document.getElementById("layer2").addEventListener("change", function() {
                layer2.visible = this.checked;
            });
            document.getElementById("layer3").addEventListener("change", function() {
                layer3.visible = this.checked;
            });
        }
    });
    </script>

</body>

</html>