<!DOCTYPE html>
<html lang="en">
<head>
  <title>SPC Outlook Mapper</title>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="" />

  <!-- calls for the arcgis api's CSS file and JS library. -->
  <link rel="stylesheet" href="https://js.arcgis.com/4.25/esri/themes/light/main.css">
  <script src="https://js.arcgis.com/4.25/"></script>

  <!-- Adding the modules, API key, and map constant needed for a full screen map app -->
  <script>
    require([
        "esri/config",
        "esri/Map",
        "esri/views/MapView",
        "esri/layers/GeoJSONLayer"

    ], function (esriConfig, Map, MapView, GeoJSONLayer) {

        esriConfig.apiKey = "AAPKfb3b968ef66d4c848e795b3dd01897e8uTic-7qcXbjlpUVMGReQlWKWAjnWq5pH5r7mLxpcFbX1tfR5Y4bLBPhLOwFOm7NL";

        var date = new Date();
        var year = date.getUTCFullYear();
        var month = ('0' + (date.getUTCMonth() + 1)).slice(-2);
        var day = ('0' + date.getUTCDate()).slice(-2);
        var hour = date.getUTCHours().toString().padStart(2, '0');

        var availableHours = [1, 12, 13, 16.5, 20];
        var closestHour;

        if (hour < availableHours[0]) {
            closestHour = availableHours[availableHours.length - 1];
            date.setDate(date.getDate() - 1);
            year = date.getUTCFullYear();
            month = ('0' + (date.getUTCMonth() + 1)).slice(-2);
            day = ('0' + (date.getUTCDate()).slice(-2));
        } else {
            closestHour = availableHours.reduce(function(prev, curr) {
                return (curr <= hour && Math.abs(curr - hour) < Math.abs(prev - hour) ? curr : prev);
            });
        }

        function getPreviousHour(hour, date) {
          var index = availableHours.indexOf(hour);
          if (index > 0) {
              return { hour: availableHours[index - 1], date: date };
          } else {
              date.setDate(date.getDate() - 1);
              var year = date.getUTCFullYear();
              var month = ('0' + (date.getUTCMonth() + 1)).slice(-2);
              var day = ('0' + date.getUTCDate()).slice(-2);
              return { hour: availableHours[availableHours.length - 1], date: { year: year, month: month, day: day } };
          }
        }

        function getUrl(hour, date) {
            hour = ('0' + Math.floor(hour)).slice(-2) + ('0' + Math.round((hour % 1) * 60)).slice(-2);
            hour = hour.toString().padStart(2, '0');
            var formattedDateTime = date.year + date.month + date.day + '_' + hour;
            return "https://ham-shack-pi.tail8c79a.ts.net/proxy?url=https://www.spc.noaa.gov/products/outlook/archive/2024/day1otlk_" + formattedDateTime + "_cat.lyr.geojson";
        }

        var closestHourStr = closestHour.toString().padStart(2, '0');
        var formattedDateTime = year + month + day + '_' + closestHourStr + '00';

        var url = "https://ham-shack-pi.tail8c79a.ts.net/proxy?url=https://www.spc.noaa.gov/products/outlook/archive/2024/day1otlk_" + formattedDateTime + "_cat.lyr.geojson";
        console.log(url);

        fetch(url)
            .then(function(response) {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(function(data) {
                // Data for the new hour is available, proceed as normal
                createGeoJSONLayer(url);
            })
            .catch(function(error) {
                // Data for the new hour is not available, use the previous hour
                var previous = getPreviousHour(closestHour, date);
                url = getUrl(previous.hour, previous.date);
                createGeoJSONLayer(url);
            });

        function createGeoJSONLayer(url) {
          var geojsonLayer = new GeoJSONLayer({
              url: url,
              renderer: {
                type: "simple",  // autocasts as new SimpleRenderer()
                symbol: {
                    type: "simple-fill",  // autocasts as new SimpleFillSymbol()
                    color: "blue",
                    outline: {  // autocasts as new SimpleLineSymbol()
                        width: 1,
                        color: "white"
                    }
                },
                visualVariables: [{
                    type: "color",
                    field: "DN",
                    stops: [
                        { value: "2", color: [0, 128, 0, 0.5] }, // green with 50% transparency
                        { value: "3", color: [255, 255, 0, 0.5] }, // yellow with 50% transparency
                        { value: "4", color: [255, 165, 0, 0.5] }, // orange with 50% transparency
                        { value: "5", color: [255, 0, 0, 0.5] }, // red with 50% transparency
                        { value: "6", color: [255, 192, 203, 0.5] } // pink with 50% transparency
                    ]
                }]
            },
            labelingInfo: [{
                labelExpressionInfo: { expression: "$feature.LABEL" },
                symbol: {
                    type: "text",
                    color: "black",
                    haloColor: "white",
                    haloSize: "1px",
                    font: { size: 15 }
                }
            }],
            popupTemplate: {  // autocasts as new PopupTemplate()
                title: "Categorical Outlook",
                content: "{LABEL2}"
            }
          });

          var map = new Map({
              basemap: "topo-vector",
              layers: [geojsonLayer]
          });

          var view = new MapView({
              container: "viewDiv", // Reference to the scene div created in step 5
              map: map, // Reference to the map object created before the scene
              zoom: 5, // Sets the zoom level based on level of detail (LOD), this is what I think looks the best
              center: [-98.5795, 37.8283] // Sets the center point of view in lon/lat
          });
        }
    });
  </script>

  <!-- css to make a full screen map -->
  <style>
    html,
    body,
    #viewDiv {
      padding: 0;
      margin: 0;
      height: 100%; 
      width: 100%;
    }
  </style>

</head>
<body>

  <!-- the div to displays the map  -->
  <div id="viewDiv"></div>

</body>
</html>